Experimental Tests
==================

.. note::

   Experimental tests may be moved to the default test section at some point.
   As that time their name would be changed, and the old name will become
   deprecated (though for a time, just as a deprecation warning).

test_all_models_register_on_metadata
------------------------------------
Diffs the set of tables registered by alembic's :code:`env.py` versus the set
of full tables we find throughout your models package/module.

Enabling this test (TL;DR)
~~~~~~~~~~~~~~~~~~~~~~~~~~
You can either enable this test with no configuration, which will attempt to
identify the source module from which the :code:`env.py` is loading its
:code:`MetaData` and automatically search in that module/package

.. code-block:: toml
   :caption: pyproject.toml/setup.cfg/pytest.ini

   # pyproject.tomlm
   [tool.pytest.ini_options]
   pytest_alembic_include_experimental = 'all_models_register_on_metadata'

   # or setup.cfg/pytest.ini
   [tool:ini_options]
   pytest_alembic_include_experimental = all_models_register_on_metadata


Or you can manually import and execute the test somewhere in your own tests.
Using this mechanism, you would be able to circumvent the automatic detection
and provide the module/package directly.


.. code-block:: python

   from pytest_alembic import tests

   def test_all_models_register_on_metadata(alembic_runner):
      tests.experimental.test_all_models_register_on_metadata(alembic_runner, 'package.models')


Explanation
~~~~~~~~~~~
The problem this test attempts to solve is best described with an example. Consider
the following package:

.. code-block::

   package/
     models/
        __init__.py
        foo.py
        bar.py
        baz.py
     other_packages/
     other_modules.py

   migrations/
      env.py


.. code-block:: python
   :caption: __init__.py

   import sqlalchemy
   from sqlalchemy import Column, types
   from sqlalchemy.ext.declarative import declarative_base

   Base = declarative_base()

   from package.models import (
      foo,
      bar,
   )

A typical models package might be defined as such, or may be otherwise superficially
different. However, it's typical to ensure that models defined outside this file
are, regardless, imported either through this file, or through a parent package
to this one. We'll see why later.

.. code-block:: python
   :caption: foo/bar/baz.py

   from package.models import Base

   class Foo/Bar/Baz(Base):
    __tablename__ = "foo/bar/baz"

    id = Column(types.Integer(), autoincrement=True, primary_key=True)


The specifics of the table definitions are not particularly important.

.. code-block:: python
   :caption: env.py

   ...
   from package.models import Base
   target_metadata = Base.metadata
   ...
   with connectable.connect() as connection:
       context.configure(connection=connection, target_metadata=target_metadata)
       ...


Above is an excerpt from what is commonly autogenerated by :code:`alembic init`.

And now we get to the crux of the problem. your :code:`other_packages/other_modules`
code can, and will likely, import all of your models at some point. So when you go
to actually use the models all will seem well.

However, as far as alembic is concerned, when it loads the :code:`env.py`, it only
imports :code:`package.models`, which notably omits :code:`package.models.baz`.
So when you go to :code:`alembic revision --autogenerate`, it will be unaware of the
"baz" table and either omit its creation or suggest it be dropped if you had already
created it.

This test is meant to be a lint against such scenarios and will fail in any case
where there is no direct import of any tables defined on a `MetaData` during the
course of executing the :code:`env.py` through alembic.
